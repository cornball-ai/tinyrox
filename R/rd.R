#' Generate Rd File Content
#'
#' @param tags Parsed tags from parse_tags().
#' @param formals Character vector of formal argument names (for functions).
#' @param source_file Source file path (for header comment).
#' @return Character string of Rd content.
#' @keywords internal
generate_rd <- function(tags, formals = NULL, source_file = NULL) {
  lines <- character()

  # Header comment (like roxygen2)
  lines <- c(lines, "% Generated by rhydrogen: do not edit by hand")
  if (!is.null(source_file)) {
    # Include R/ prefix in path like roxygen2 does
    lines <- c(lines, paste0("% Please edit documentation in R/", basename(source_file)))
  }

  # Required sections
  lines <- c(lines, paste0("\\name{", escape_rd(tags$name), "}"))
  lines <- c(lines, paste0("\\alias{", escape_rd(tags$name), "}"))

  # Additional aliases
  for (alias in tags$aliases) {
    if (alias != tags$name) {
      lines <- c(lines, paste0("\\alias{", escape_rd(alias), "}"))
    }
  }

  # Title (required)
  title <- if (!is.null(tags$title)) tags$title else tags$name
  lines <- c(lines, paste0("\\title{", escape_rd(title), "}"))

  # Usage (for functions) - before arguments like roxygen2
  # Generate usage even for no-arg functions (formals is list with empty names)
  if (!is.null(formals)) {
    usage <- format_usage(tags$name, formals$usage)
    lines <- c(lines, "\\usage{")
    lines <- c(lines, escape_rd(usage))
    lines <- c(lines, "}")
  }

  # Arguments (for functions with params)
  if (length(tags$params) > 0) {
    lines <- c(lines, "\\arguments{")
    # Use formals order if available, otherwise param order
    formal_names <- if (!is.null(formals)) formals$names else character()
    param_order <- if (length(formal_names) > 0) {
      c(intersect(formal_names, names(tags$params)),
        setdiff(names(tags$params), formal_names))
    } else {
      names(tags$params)
    }
    for (i in seq_along(param_order)) {
      param <- param_order[i]
      # Wrap long descriptions at ~72 chars
      desc_text <- wrap_text(escape_rd(tags$params[[param]]), width = 72)
      lines <- c(lines, paste0("\\item{", escape_rd(param), "}{", desc_text, "}"))
      # Add blank line between items (except after last)
      if (i < length(param_order)) {
        lines <- c(lines, "")
      }
    }
    lines <- c(lines, "}")
  }

  # Details
  if (!is.null(tags$details)) {
    lines <- c(lines, "\\details{")
    lines <- c(lines, escape_rd(tags$details))
    lines <- c(lines, "}")
  }

  # Value/Return
  if (!is.null(tags$return)) {
    lines <- c(lines, "\\value{")
    lines <- c(lines, escape_rd(tags$return))
    lines <- c(lines, "}")
  }

  # Description - after value like roxygen2
  desc <- if (!is.null(tags$description)) {
    tags$description
  } else if (!is.null(tags$title)) {
    tags$title
  } else {
    tags$name
  }
  lines <- c(lines, "\\description{")
  lines <- c(lines, wrap_text(escape_rd(desc), width = 72))
  lines <- c(lines, "}")

  # References
  if (!is.null(tags$references)) {
    lines <- c(lines, "\\references{")
    lines <- c(lines, escape_rd(tags$references))
    lines <- c(lines, "}")
  }

  # See Also
  if (!is.null(tags$seealso)) {
    lines <- c(lines, "\\seealso{")
    lines <- c(lines, escape_rd(tags$seealso))
    lines <- c(lines, "}")
  }

  # Examples
  if (!is.null(tags$examples) && nchar(trimws(tags$examples)) > 0) {
    lines <- c(lines, "\\examples{")
    # Examples are verbatim - don't escape
    lines <- c(lines, tags$examples)
    lines <- c(lines, "}")
  }

  # Keywords
  for (kw in tags$keywords) {
    lines <- c(lines, paste0("\\keyword{", escape_rd(kw), "}"))
  }

  paste(lines, collapse = "\n")
}

#' Escape Special Characters for Rd
#'
#' Escapes special characters for Rd format, but detects and preserves
#' existing Rd markup (like \\describe{}, \\item{}, \\code{}, etc.).
#'
#' @param text Text to escape.
#' @return Escaped text.
#' @keywords internal
escape_rd <- function(text) {
  if (is.null(text)) return("")

  # Check if text contains Rd markup (backslash commands like \describe, \item, etc.)
  # If so, pass through with minimal escaping (just %)
  if (grepl("\\\\[a-zA-Z]+\\{", text)) {
    # Contains Rd markup - only escape %
    text <- gsub("%", "\\\\%", text)
    return(text)
  }

  # No Rd markup - escape all special chars
  text <- gsub("\\\\", "\\\\\\\\", text)
  text <- gsub("\\{", "\\\\{", text)
  text <- gsub("\\}", "\\\\}", text)
  text <- gsub("%", "\\\\%", text)

  text
}

#' Format Usage Line
#'
#' Formats the function usage, wrapping to multiple lines if needed.
#' Follows roxygen2 style: each argument on its own line if total > 80 chars.
#'
#' @param name Function name.
#' @param args Character vector of arguments with defaults.
#' @return Formatted usage string.
#' @keywords internal
format_usage <- function(name, args) {
  # Build single-line version
  single_line <- paste0(name, "(", paste(args, collapse = ", "), ")")

  # If short enough, use single line
  if (nchar(single_line) <= 80) {
    return(single_line)
  }

  # Otherwise, wrap to multiple lines like roxygen2
  # roxygen2 uses 2-space indent
  indent <- "  "
  lines <- character()
  lines <- c(lines, paste0(name, "("))

  for (i in seq_along(args)) {
    arg <- args[i]
    suffix <- if (i < length(args)) "," else ""
    lines <- c(lines, paste0(indent, arg, suffix))
  }

  lines <- c(lines, ")")
  paste(lines, collapse = "\n")
}

#' Wrap Text to Width
#'
#' Wraps text to specified width, preserving words.
#'
#' @param text Text to wrap.
#' @param width Maximum line width.
#' @return Wrapped text with newlines.
#' @keywords internal
wrap_text <- function(text, width = 72) {
  if (is.null(text) || nchar(text) <= width) {
    return(text)
  }

  # Split into words

  words <- strsplit(text, "\\s+")[[1]]
  if (length(words) == 0) return(text)

  lines <- character()
  current_line <- words[1]

  for (word in words[-1]) {
    test_line <- paste(current_line, word)
    if (nchar(test_line) <= width) {
      current_line <- test_line
    } else {
      lines <- c(lines, current_line)
      current_line <- word
    }
  }
  lines <- c(lines, current_line)

  paste(lines, collapse = "\n")
}

#' Write Rd File
#'
#' @param content Rd content string.
#' @param name Topic name.
#' @param path Package root path.
#' @keywords internal
write_rd <- function(content, name, path = ".") {
  man_dir <- file.path(path, "man")

  if (!dir.exists(man_dir)) {
    dir.create(man_dir, recursive = TRUE)
  }

  # Sanitize filename (replace . with - for internal functions)
  filename <- gsub("^\\.", "dot-", name)
  filepath <- file.path(man_dir, paste0(filename, ".Rd"))

  writeLines(content, filepath, useBytes = TRUE)

  filepath
}

#' Generate All Rd Files for a Package
#'
#' @param blocks List of documentation blocks from parse_package().
#' @param path Package root path.
#' @return Character vector of generated file paths.
#' @keywords internal
generate_all_rd <- function(blocks, path = ".") {
  generated <- character()
  topics_seen <- character()

  for (block in blocks) {
    # Parse tags
    tags <- parse_tags(
      block$lines,
      block$object,
      block$file,
      block$line
    )

    # Skip if @noRd or namespace-only block
    if (tags$noRd || block$type == "namespace_only") {
      next
    }

    # Check for duplicate topics
    if (tags$name %in% topics_seen) {
      warning("Duplicate topic '", tags$name, "' - skipping",
              call. = FALSE)
      next
    }
    topics_seen <- c(topics_seen, tags$name)

    # Generate Rd content
    rd_content <- generate_rd(tags, block$formals, block$file)

    # Write file
    filepath <- write_rd(rd_content, tags$name, path)
    generated <- c(generated, filepath)

    # Warn about undocumented params
    if (block$type == "function" && !is.null(block$formals)) {
      formal_names <- block$formals$names
      undoc <- setdiff(formal_names, names(tags$params))
      # Filter out ... which is often intentionally undocumented
      undoc <- setdiff(undoc, "...")
      if (length(undoc) > 0) {
        warning("Undocumented parameters in ", tags$name, ": ",
                paste(undoc, collapse = ", "),
                call. = FALSE)
      }
    }
  }

  generated
}
