#' Generate Rd File Content
#'
#' @param tags Parsed tags from parse_tags().
#' @param formals Character vector of formal argument names (for functions).
#' @param source_file Source file path (for header comment).
#' @return Character string of Rd content.
#' @keywords internal
generate_rd <- function(tags, formals = NULL, source_file = NULL) {
  lines <- character()

  # Header comment (like roxygen2)
  lines <- c(lines, "% Generated by rhydrogen: do not edit by hand")
  if (!is.null(source_file)) {
    # Include R/ prefix in path like roxygen2 does
    lines <- c(lines, paste0("% Please edit documentation in R/", basename(source_file)))
  }

  # Required sections
  lines <- c(lines, paste0("\\name{", escape_rd(tags$name), "}"))
  lines <- c(lines, paste0("\\alias{", escape_rd(tags$name), "}"))

  # Additional aliases
  for (alias in tags$aliases) {
    if (alias != tags$name) {
      lines <- c(lines, paste0("\\alias{", escape_rd(alias), "}"))
    }
  }

  # Title (required)
  title <- if (!is.null(tags$title)) tags$title else tags$name
  lines <- c(lines, paste0("\\title{", escape_rd(title), "}"))

  # Usage (for functions) - before arguments like roxygen2
  # Generate usage even for no-arg functions (formals is list with empty names)
  if (!is.null(formals)) {
    usage <- format_usage(tags$name, formals$usage)
    lines <- c(lines, "\\usage{")
    lines <- c(lines, escape_rd(usage))
    lines <- c(lines, "}")
  }

  # Arguments (for functions with params)
  if (length(tags$params) > 0) {
    lines <- c(lines, "\\arguments{")
    # Use formals order if available, otherwise param order
    formal_names <- if (!is.null(formals)) formals$names else character()
    param_order <- if (length(formal_names) > 0) {
      c(intersect(formal_names, names(tags$params)),
        setdiff(names(tags$params), formal_names))
    } else {
      names(tags$params)
    }
    for (i in seq_along(param_order)) {
      param <- param_order[i]
      # Wrap long descriptions at ~72 chars
      desc_text <- wrap_text(escape_rd(tags$params[[param]]), width = 72)
      lines <- c(lines, paste0("\\item{", escape_rd(param), "}{", desc_text, "}"))
      # Add blank line between items (except after last)
      if (i < length(param_order)) {
        lines <- c(lines, "")
      }
    }
    lines <- c(lines, "}")
  }

  # Details
  if (!is.null(tags$details)) {
    lines <- c(lines, "\\details{")
    lines <- c(lines, escape_rd(tags$details))
    lines <- c(lines, "}")
  }

  # Value/Return
  if (!is.null(tags$return)) {
    lines <- c(lines, "\\value{")
    lines <- c(lines, escape_rd(tags$return))
    lines <- c(lines, "}")
  }

  # Description - after value like roxygen2
  desc <- if (!is.null(tags$description)) {
    tags$description
  } else if (!is.null(tags$title)) {
    tags$title
  } else {
    tags$name
  }
  lines <- c(lines, "\\description{")
  lines <- c(lines, wrap_text(escape_rd(desc), width = 72))
  lines <- c(lines, "}")

  # References
  if (!is.null(tags$references)) {
    lines <- c(lines, "\\references{")
    lines <- c(lines, escape_rd(tags$references))
    lines <- c(lines, "}")
  }

  # See Also
  if (!is.null(tags$seealso)) {
    lines <- c(lines, "\\seealso{")
    lines <- c(lines, escape_rd(tags$seealso))
    lines <- c(lines, "}")
  }

  # Examples
  if (!is.null(tags$examples) && nchar(trimws(tags$examples)) > 0) {
    lines <- c(lines, "\\examples{")
    # Examples are verbatim - don't escape
    lines <- c(lines, tags$examples)
    lines <- c(lines, "}")
  }

  # Keywords
  for (kw in tags$keywords) {
    lines <- c(lines, paste0("\\keyword{", escape_rd(kw), "}"))
  }

  paste(lines, collapse = "\n")
}

#' Escape Special Characters for Rd
#'
#' Escapes special characters for Rd format, but detects and preserves
#' existing Rd markup (like \\describe{}, \\item{}, \\code{}, etc.).
#'
#' @param text Text to escape.
#' @return Escaped text.
#' @keywords internal
escape_rd <- function(text) {
  if (is.null(text)) return("")

  # Check if text contains Rd markup (backslash commands like \describe, \item, etc.)
  # If so, pass through with minimal escaping (just %)
  if (grepl("\\\\[a-zA-Z]+\\{", text)) {
    # Contains Rd markup - only escape %
    text <- gsub("%", "\\\\%", text)
    return(text)
  }

  # No Rd markup - escape all special chars
  text <- gsub("\\\\", "\\\\\\\\", text)
  text <- gsub("\\{", "\\\\{", text)
  text <- gsub("\\}", "\\\\}", text)
  text <- gsub("%", "\\\\%", text)

  text
}

#' Format Usage Line
#'
#' Formats the function usage, wrapping to multiple lines if needed.
#' Follows roxygen2 style: each argument on its own line if total > 80 chars.
#'
#' @param name Function name.
#' @param args Character vector of arguments with defaults.
#' @return Formatted usage string.
#' @keywords internal
format_usage <- function(name, args) {
  # Build single-line version
  single_line <- paste0(name, "(", paste(args, collapse = ", "), ")")

  # If short enough, use single line
  if (nchar(single_line) <= 80) {
    return(single_line)
  }

  # Otherwise, wrap to multiple lines like roxygen2
  # roxygen2 uses 2-space indent
  indent <- "  "
  lines <- character()
  lines <- c(lines, paste0(name, "("))

  for (i in seq_along(args)) {
    arg <- args[i]
    suffix <- if (i < length(args)) "," else ""
    lines <- c(lines, paste0(indent, arg, suffix))
  }

  lines <- c(lines, ")")
  paste(lines, collapse = "\n")
}

#' Wrap Text to Width
#'
#' Wraps text to specified width, preserving words.
#'
#' @param text Text to wrap.
#' @param width Maximum line width.
#' @return Wrapped text with newlines.
#' @keywords internal
wrap_text <- function(text, width = 72) {
  if (is.null(text) || nchar(text) <= width) {
    return(text)
  }

  # Split into words

  words <- strsplit(text, "\\s+")[[1]]
  if (length(words) == 0) return(text)

  lines <- character()
  current_line <- words[1]

  for (word in words[-1]) {
    test_line <- paste(current_line, word)
    if (nchar(test_line) <= width) {
      current_line <- test_line
    } else {
      lines <- c(lines, current_line)
      current_line <- word
    }
  }
  lines <- c(lines, current_line)

  paste(lines, collapse = "\n")
}

#' Write Rd File
#'
#' @param content Rd content string.
#' @param name Topic name.
#' @param path Package root path.
#' @keywords internal
write_rd <- function(content, name, path = ".") {
  man_dir <- file.path(path, "man")

  if (!dir.exists(man_dir)) {
    dir.create(man_dir, recursive = TRUE)
  }

  # Sanitize filename (replace . with - for internal functions)
  filename <- gsub("^\\.", "dot-", name)
  filepath <- file.path(man_dir, paste0(filename, ".Rd"))

  writeLines(content, filepath, useBytes = TRUE)

  filepath
}

#' Generate All Rd Files for a Package
#'
#' @param blocks List of documentation blocks from parse_package().
#' @param path Package root path.
#' @return Character vector of generated file paths.
#' @keywords internal
generate_all_rd <- function(blocks, path = ".") {
  generated <- character()
  topics_seen <- character()

  # First pass: parse all blocks and build lookup for @inheritParams
  all_tags <- list()
  all_blocks <- list()

  for (block in blocks) {
    tags <- parse_tags(
      block$lines,
      block$object,
      block$file,
      block$line
    )

    # Skip namespace-only blocks
    if (block$type == "namespace_only") {
      next
    }

    all_tags[[tags$name]] <- tags
    all_blocks[[tags$name]] <- block
  }

  # Second pass: resolve @inheritParams and generate Rd files
  for (name in names(all_tags)) {
    tags <- all_tags[[name]]
    block <- all_blocks[[name]]

    # Skip if @noRd
    if (tags$noRd) {
      next
    }

    # Handle package documentation specially
    if (block$type == "package") {
      pkg_name <- get_package_name(path)
      rd_content <- generate_package_rd(tags, pkg_name, block$file)
      filepath <- write_rd(rd_content, paste0(pkg_name, "-package"), path)
      generated <- c(generated, filepath)
      next
    }

    # Check for duplicate topics
    if (tags$name %in% topics_seen) {
      warning("Duplicate topic '", tags$name, "' - skipping",
              call. = FALSE)
      next
    }
    topics_seen <- c(topics_seen, tags$name)

    # Resolve @inheritParams
    if (length(tags$inheritParams) > 0) {
      tags <- resolve_inherit_params(tags, all_tags, block$formals)
    }

    # Generate Rd content (nn_module uses formals like function)
    rd_content <- generate_rd(tags, block$formals, block$file)

    # Write file
    filepath <- write_rd(rd_content, tags$name, path)
    generated <- c(generated, filepath)

    # Warn about undocumented params (for functions and nn_modules)
    if (block$type %in% c("function", "nn_module") && !is.null(block$formals)) {
      formal_names <- block$formals$names
      undoc <- setdiff(formal_names, names(tags$params))
      # Filter out ... which is often intentionally undocumented
      undoc <- setdiff(undoc, "...")
      if (length(undoc) > 0) {
        warning("Undocumented parameters in ", tags$name, ": ",
                paste(undoc, collapse = ", "),
                call. = FALSE)
      }
    }
  }

  generated
}

#' Get Package Name from DESCRIPTION
#'
#' @param path Package root path.
#' @return Package name.
#' @keywords internal
get_package_name <- function(path) {
  desc_file <- file.path(path, "DESCRIPTION")
  if (!file.exists(desc_file)) {
    return("unknown")
  }
  desc <- read.dcf(desc_file, fields = "Package")
  as.character(desc[1, 1])
}

#' Generate Package Documentation Rd
#'
#' Generates Rd content for package documentation ("_PACKAGE" directive).
#'
#' @param tags Parsed tags from the documentation block.
#' @param pkg_name Package name.
#' @param source_file Source file path.
#' @return Character string of Rd content.
#' @keywords internal
generate_package_rd <- function(tags, pkg_name, source_file) {
  lines <- character()

  # Header
  lines <- c(lines, "% Generated by rhydrogen: do not edit by hand")
  if (!is.null(source_file)) {
    lines <- c(lines, paste0("% Please edit documentation in R/", basename(source_file)))
  }

  # docType
  lines <- c(lines, "\\docType{package}")

  # Name and aliases
  lines <- c(lines, paste0("\\name{", pkg_name, "-package}"))
  lines <- c(lines, paste0("\\alias{", pkg_name, "}"))
  lines <- c(lines, paste0("\\alias{", pkg_name, "-package}"))

  # Title - don't duplicate package name if title already starts with it
  title <- if (!is.null(tags$title)) {
    if (grepl(paste0("^", pkg_name, ":"), tags$title, ignore.case = TRUE)) {
      tags$title
    } else {
      paste0(pkg_name, ": ", tags$title)
    }
  } else {
    pkg_name
  }
  lines <- c(lines, paste0("\\title{", escape_rd(title), "}"))

  # Description
  if (!is.null(tags$description)) {
    lines <- c(lines, "\\description{")
    lines <- c(lines, wrap_text(escape_rd(tags$description), width = 72))
    lines <- c(lines, "}")
  }

  # Sections (like @section Core packages:)
  if (!is.null(tags$sections)) {
    for (sec in tags$sections) {
      lines <- c(lines, paste0("\\section{", escape_rd(sec$title), "}{"))
      lines <- c(lines, sec$content)  # Content may have Rd markup, don't escape
      lines <- c(lines, "}")
    }
  }

  # Author (from tags or leave empty)
  if (!is.null(tags$author)) {
    lines <- c(lines, "\\author{")
    lines <- c(lines, escape_rd(tags$author))
    lines <- c(lines, "}")
  }

  # Keywords
  for (kw in tags$keywords) {
    lines <- c(lines, paste0("\\keyword{", escape_rd(kw), "}"))
  }

  paste(lines, collapse = "\n")
}

#' Resolve @inheritParams Tags
#'
#' Copies parameter documentation from source functions to the current function.
#' Only inherits params that are: (1) in the current function's formals, and
#' (2) not already documented in the current function.
#'
#' @param tags Current function's parsed tags.
#' @param all_tags Named list of all parsed tags (name -> tags).
#' @param formals Current function's formals (list with names and usage).
#' @return Updated tags with inherited params merged in.
#' @keywords internal
resolve_inherit_params <- function(tags, all_tags, formals) {
  # Get the current function's formal parameter names

  formal_names <- if (!is.null(formals)) formals$names else character()

  for (source_name in tags$inheritParams) {
    # Handle pkg::function syntax
    if (grepl("::", source_name)) {
      # External package - skip for now (would need to load package)
      # TODO: Support external packages
      next
    }

    # Look up source function's tags
    source_tags <- all_tags[[source_name]]

    if (is.null(source_tags)) {
      warning("@inheritParams: source function '", source_name,
              "' not found in package", call. = FALSE)
      next
    }

    # Copy params that are in our formals and not already documented
    for (param_name in names(source_tags$params)) {
      # Only inherit if param is in our formals
      if (!param_name %in% formal_names) {
        next
      }

      # Only inherit if not already documented
      if (param_name %in% names(tags$params)) {
        next
      }

      # Inherit the param
      tags$params[[param_name]] <- source_tags$params[[param_name]]
    }
  }

  tags
}
